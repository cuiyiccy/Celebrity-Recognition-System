"""Module containing models for facial recognition on the Friends TV show.

This module includes classes for both binary and multiclass classification using
neural networks built with PyTorch. It also contains a baseline model for
comparison.
"""

import torch
from typing import List
from constants import LABELS, LABELS_MAP, DEVICE
from dataset import FriendsDataset


class BinaryClassifier(torch.nn.Module):
    """A binary classification neural network for facial recognition.

    This model is designed for binary classification tasks and uses a simple
    feedforward neural network with batch normalization, dropout, and sigmoid
    activation for the output layer.
    """

    def __init__(self) -> None:
        super(BinaryClassifier, self).__init__()
        self.classifier = torch.nn.Sequential(
            torch.nn.Linear(512, 128),
            torch.nn.BatchNorm1d(128),
            torch.nn.Dropout(0.1),
            torch.nn.Linear(128, 32),
            torch.nn.Linear(32, 1),
            torch.nn.Sigmoid(),
        )

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Forward pass of the classifier."""
        return self.classifier(x).squeeze(dim=-1)

    def predict(self, x: torch.Tensor) -> List[str]:
        self.classifier.eval()
        outputs = self(x)
        outputs[outputs > 0.5] = 1
        outputs[outputs <= 0.5] = 0

        return [LABELS[int(label)] for label in outputs]


class MulticlassClassifier(torch.nn.Module):
    """A multiclass classification neural network for facial recognition.

    This model is designed for multiclass classification tasks and utilizes a
    similar architecture to the BinaryClassifier but with a softmax output layer
    for multi-class probabilities.
    """

    def __init__(self, num_classes: int = len(LABELS_MAP)) -> None:
        super(MulticlassClassifier, self).__init__()
        self.classifier = torch.nn.Sequential(
            torch.nn.Linear(512, 128),
            torch.nn.BatchNorm1d(128),
            torch.nn.Dropout(0.1),
            torch.nn.Linear(128, 32),
            torch.nn.Linear(32, num_classes),
            torch.nn.Softmax(dim=1),
        )

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Forward pass of the classifier."""
        return self.classifier(x)

    def predict(self, x: torch.Tensor) -> List[str]:
        self.classifier.eval()
        outputs = self(x)

        return [LABELS[int(label)] for label in outputs.argmax(dim=-1)]


class BaselineModel:
    """Baseline model for facial recognition using nearest neighbor search.

    This model uses a simple nearest neighbor approach to classify faces based
    on the embeddings generated by a pre-trained network.
    """

    def __init__(self, img_dir: str = "samples") -> None:
        # Load embeddings and labels from the dataset
        embeddings = []
        self.labels: List[int] = []
        for embedding, label, _ in torch.utils.data.DataLoader(
            FriendsDataset(img_dir)
        ):
            embeddings.append(embedding)
            self.labels.append(label)
        self.embeddings = torch.stack(embeddings).squeeze().to(DEVICE)

    def __call__(
        self,
        x: torch.Tensor,
        threshold: float = 1.0,
        labels: set[int] = set(LABELS_MAP.values()),
    ) -> torch.Tensor:
        """Classifies an input embedding based on the nearest neighbor.

        Args:
            x: The input embedding tensor.
            threshold: Threshold distance for classification.
            labels: A set of valid labels.

        Returns:
            The predicted labels.
        """
        batch_size = x.size()[0]
        embeddings = self.embeddings.expand(
            batch_size, *self.embeddings.size()
        )
        dists = (embeddings - x.unsqueeze(dim=1)).norm(dim=-1)
        min_dists, bests = dists.min(dim=1)
        outputs = [
            self.labels[best]
            if int(self.labels[best]) in labels and dist < threshold
            else 0
            for best, dist in zip(bests, min_dists)
        ]

        return torch.Tensor(outputs)

    def train(self, _: bool) -> None:
        """No-op."""
        pass

    def predict(self, x: torch.Tensor) -> List[str]:
        return [LABELS[int(label)] for label in self(x)]


# Test only
if __name__ == "__main__":
    loader = torch.utils.data.DataLoader(
        FriendsDataset(img_dir="samples"), batch_size=2, shuffle=True
    )
    models = {
        "binary_classifier": BinaryClassifier().eval(),
        "multiclass_classifier": MulticlassClassifier().eval(),
        "baseline_model": BaselineModel(),
    }
    for inputs, labels, _ in loader:
        print("inputs:", inputs.size(), labels, [LABELS[l] for l in labels])
        for name, model in models.items():
            print(f"{name}: {model(inputs).size()}")
            print(f"{name}: {model.predict(inputs)}")
        break
